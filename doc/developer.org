#+TITLE: LCATR Job Developer Instructions
#+SETUPFILE: setup.org

Instructions for an LSST CCD Test Software Developer

This document describes the steps needed to make your LSST CCD (or
RTM) test or analysis software work in a production setting.  Besides
the first section it gives only brief instructions; the "what to do"
if not the "why to do it".

* Introduction

Your software which performs a CCD (or RTM) test or an analysis of
test output must adhere to several requirements in order for it to run
in a production setting.  In order to assure requirements are met your
software is not directly run by an operator (user) but rather is run
through a "shim" program called the /job harness/.  To "glue" your
software to this shim you must satisfy the following steps:

 0) Develop your software.  This can be done separately from the rest
    of the steps but they are best taken under consideration.

 1) Develop the two main programs called by the harness.

 2) Provide a file that describes the required environment variables.

 3) Pushed tagged releases of your software into a remote git
    repository.

 4) Provide suitable installation instructions or mechanisms.

The instructions for each step are described in detail in the rest of
this document.  In addition, for information about testing your
software under the job harness see the document "[[./testing.org][LCATR Testing]]".

* Develop your software

Your software may be written in a variety of ways but some general
rules to keep in mind:

 - it must run in "batch" or command line mode and not require any
   interactive input.  

 - it must write any important output files to the current working
   directory, writing outside of this directory is not allowed.

 - it should name files in a static manner and not encode variable
   information such as the CCD ID, time stamps.  This rule is
   particularly important for any files that must be read into
   subsequent analysis jobs

 - if it requires a MS Windows host it must be able to run from the
   Cygwin environment


* Two main programs

The harness will run two programs one after the other which are
provided by your software.  They may be named as you like but first is
identified as the /producer/ and the second as the /validator/.  They
will likely be written as interpreted scripts but need not be.

The /producer/ program is meant to perform the primary functionality
your test or analysis software.  It is free to produce any needed
output files which may be in any desired format.

The validator program has two responsibilities.  First, it should
perform any validation on the output of the producer that the author
sees fitting.  Second it must produce a =summary.lims= file that is in
a schema-compliant format.  See the document "[[./schema.org][LCATR Schema]]" for
details on producing this file.

* Environment

To define the environment your software must provide an Environment
Module[fn:modules].  In this file all variables required
by the harness to run your software must be defined.  These variables
can be defined automatically by including this boilerplate:

#+begin_src Tcl
#%Module1.0 #-*-tcl-*-#
source "$::env(LCATR_MODULES)/lcatr.tcl"
lcatr_package PRODUCER VALIDATOR
#+end_src

Replace the strings =PRODUCER= and =VALIDATOR= with the names of your
producer and validator executable files.  They should be specified as
paths relative to the software's top-level installation directory
(more on installation below).

If your software requires additional environment variables they may be
included in this file as well.  Keep in mind that any information
about individual units of testing have no place here.

Environment Modules are described at http://modules.sf.net/ and see
the document "[[./modulefiles.org][LCATR Environment Modules]]" for details about writing
them for your software.

** Finding input files

One special environment variable that your producer will need to use
if it reads in files that were produced from other jobs that have been
run on the same unit of test is the =LCATR_DEPENDENCY_PATH=.  This
variable holds a ":"-delimited list of directories that contain output
file from the prior jobs run on the same CCD (or RTM) that your
software is testing.  This directory path list is the sole mechanism
for dependent packages to find input files that were produced as
output from prior jobs.  

If you write your producer in Python the function =dependency_glob()=
will help you search for a files matching a pattern in this path.

#+BEGIN_SRC Python
from lcatr.harness.helpers import dependency_glob
filenames = dependency_glob("somefile_*.data")
for filename in filenames:
  f = open(filenames[0])
  data = f.read()
  ...
#+END_SRC




* Tagged release

All production code must be specified by a tag in a git repository.
This section gives brief commands on how to perform the required git
mechanics.

** Git repository setup

Before getting starting a repository must be requested from the site
git repository manager.  You should provide the canonical name for
your software and you will be given a git URL.  If you do not yet have
a local git repository you will clone the (empty) new one and fill it
with your software files.  If you are already using git to manage your
software you will add this new repository as a remote.  The following
examples use an existing (non-empty) repository.

Clone a remote git repository:

#+begin_example
git clone https://git.racf.bnl.gov/astro/git/lcatr/jobs/example_station_A.git
#+end_example

When done, the remote name defaults to "origin".  To add a remote
repository to an already existing local one do:

#+begin_example
git remote add <remotename> https://git.racf.bnl.gov/astro/git/lcatr/jobs/example_station_A.git
#+end_example

** Tagging a release

To tag a release one runs the following from your local git-controlled area

#+begin_example
git tag <tagname> [<commit> | <object>]
#+end_example

The form of the tag name is left to your discretion but it is
recommended that some convention is chosen and carefully followed.  By
default this will tag the current "head" commit.  If another commit is
desired its hash may be specified.  Running =gitk= can help identify
the commit.

Git allows for changing a tag after it has been made.  This should be
strongly avoided but, strictly speaking, it will only cause a problem
if done after the tag was used to install, select and run your
software in a production setting.

** Pushing a release

So far you have only made changes to your local repository.  To send
the commits associated with the tag you "push" them like:

#+begin_example
git push <remotename> <tagname>
#+end_example

** Advertising a release

After the git mechanics above are complete, the next step is to inform
the software manager that a new release has been made and requires
installation.  This notification should include at least:

 - the tag name you chose to release

 - the remote (cgit) repository URL

 - on which machines the software needs installing

 - installation and validation instructions

It is expected that only the first item will change from release to
release.




* Installation

See above for advertising the existence of a new release.  

** Installation Location

The software manager will arrange for your software to be put in the
"install area" for the host machines that require it.  Your software
will be installed in a directory located via:

#+begin_example
<install area>/<name>/<tag>/
#+end_example

Where the =<name>= is the canonical name of your software and the
=<tag>= is the reported git tag.

** Mechanism

The installation mechanism must be provided by you and you are free to
use any reasonable approach.  The software manager will run your
installation mechanism with the above directory as the installation
root (a.k.a. the "prefix" in used by some installation mechanisms).








