#+TITLE: LCATR Job Developer Instructions
#+SETUPFILE: setup.org

This document describes the steps needed to make your LSST CCD (or
RTM) test or analysis software work in a production testing setting.
Compliant software will be run based on a specifically installed
version, its results will be archived in an organized fashion and will
be run only when any required previous jobs have finished and their
output is available, and finally will have a summary uploaded to the
LIMS database for future querying.  To achieve these goals in a
uniform manner your software must run under a job /harness/.

* Introduction

In order to be "harnessed" your software must be augmented to satisfy
the following aspects:

 - Provide an installation mechanism that fits into the versioning
   system.

 - Provide the required executable entry points.

 - Adhere to output file location rules.

It is expected that these aspects can be satisfied by writing thing
"shim" scripts that "glue" your existing software into the job
harness.  The expected, general steps to follow are:

 0) Develop your software.  This can be done separately from the rest
    of the steps but they are best taken under consideration.

 1) Develop the required two main programs (/producer/ and
    /validator/) called by the harness for each atomic job.

 2) Provide an environment /modulefile/ that describes the required
    environment variables and a suitable installation mechanism.

 3) Push tagged releases of your software into a remote git
    repository.

The instructions for each step are described in detail in the rest of
this document.  In addition, for information about testing your
software under the job harness see the document "[[./testing.org][LCATR Testing]]".

** Scope considerations

The scope of a harnessed job is a balance between being as inclusive
as possible to avoid a proliferation of jobs (and their developer
overheard) and being as atomic as possible so that one problem does
lead to an abort an loss of progress.  It's up to the developer to
determine this.  Some guidelines:

 - A job is considered successful for failed; there is no middle
   ground.  If it is to be re-run it must start from the beginning.

 - Success should be judged on the job finishing the processing with
   no fatal errors and not on the actual results (eg, a busted CCD can
   still be successfully tested).

 - The job must finish completely and successfully before its summary
   results are uploaded to LIMS.

 - Mechanisms for chaining separate but related jobs are possible.

** Naming

The harness identifies a job by its /canonical name/ (and its
installed /version/).  Once a name is selected it becomes a reserved
identifier in various parts of the system.  Since it is a primary
descriptor it is best for the named test to not evolve far beyond its
original intention.  If a radical change is needed then a new
canonical name should be chosen.  


* Develop your software

Your software may be written in a variety of ways but some general
rules to keep in mind:

 - it must run in "batch" or command line mode and not require any
   interactive input.  

 - it must write any important output files to the *current working
   directory*, writing outside of this directory is not allowed.

 - if it requires a MS Windows host it must be able to run from the
   Cygwin environment

It is recommended that output file names be static from job to job and
not encode timestamps, CCD IDs, version strings, etc as these are
reflected by the job harness in the output directory path and are
recorded to the LIMS database.  Encoding this information makes it
more difficult for downstream processing to locate input files.

* Two main programs

For each atomic job, the harness will run two programs one after the
other which must be provided by your software.  They may be named as
you like but first is identified as the /producer/ and the second as
the /validator/.  They will likely be written as interpreted scripts
but need not be.

The /producer/ program is meant to perform the primary functionality
of your test or analysis software.  It is free to produce any needed
output files which may be in any desired format.

The validator program has two responsibilities.  First, it should
perform any validation on the output of the producer that the author
sees fitting.  Second it must produce a =summary.lims= file that is in
a schema-compliant format.  See the document "[[./schema.org][LCATR Schema]]" for
details on producing this file.

* Environment

To define the environment your software must provide an Environment
Module[fn:modules].  In this file all variables required
by the harness to run your software must be defined.  These variables
can be defined automatically by including this boilerplate:

[fn:modules] http://modules.sf.net/

#+begin_src Tcl
#%Module1.0 #-*-tcl-*-#
source "$::env(LCATR_MODULES)/lcatr.tcl"
lcatr_package PRODUCER VALIDATOR
#+end_src

Replace the strings =PRODUCER= and =VALIDATOR= with the names of your
producer and validator executable files.  They should be specified as
paths relative to the software's top-level installation directory
(more on installation below).

If your software requires additional environment variables they may be
included in this file as well.  Keep in mind that any information
about individual units of testing have no place here.

Environment Modules are described at http://modules.sf.net/ and see
the document "[[./modulefiles.org][LCATR Environment Modules]]" for details about writing
them for your software.

** Finding input files

One special environment variable that your producer will need to use
if it reads in files that were produced from other jobs that have been
run on the same unit of test is the =LCATR_DEPENDENCY_PATH=.  This
variable holds a ":"-delimited list of directories that contain output
file from the prior jobs run on the same CCD (or RTM) that your
software is testing.  This directory path list is the sole mechanism
for dependent packages to find input files that were produced as
output from prior jobs.  

If you write your producer in Python the function =dependency_glob()=
will help you search for a files matching a pattern in this path.

#+BEGIN_SRC Python
from lcatr.harness.helpers import dependency_glob
filenames = dependency_glob("somefile_*.data")
for filename in filenames:
  f = open(filenames[0])
  data = f.read()
  ...
#+END_SRC




* Tagged release

All production code must be specified by a tag in a git repository.
This section gives brief commands on how to perform the required git
mechanics.

** Git repository setup

Before getting starting a repository must be requested from the site
git repository manager.  You should provide the canonical name for
your software and you will be given a git URL.  If you do not yet have
a local git repository you will clone the (empty) new one and fill it
with your software files.  If you are already using git to manage your
software you will add this new repository as a remote.  The following
examples use an existing (non-empty) repository.

Clone a remote git repository:

#+begin_example
git clone https://git.racf.bnl.gov/astro/git/lcatr/jobs/example_station_A.git
#+end_example

When done, the remote name defaults to "origin".  To add a remote
repository to an already existing local one do:

#+begin_example
git remote add <remotename> https://git.racf.bnl.gov/astro/git/lcatr/jobs/example_station_A.git
#+end_example

** Tagging a release

To tag a release one runs the following from your local git-controlled area

#+begin_example
git tag <tagname> [<commit> | <object>]
#+end_example

The form of the tag name is left to your discretion but it is
recommended that some convention is chosen and carefully followed.  By
default this will tag the current "head" commit.  If another commit is
desired its hash may be specified.  Running =gitk= can help identify
the commit.

Git allows for changing a tag after it has been made.  This should be
strongly avoided but, strictly speaking, it will only cause a problem
if done after the tag was used to install, select and run your
software in a production setting.

** Pushing a release

So far you have only made changes to your local repository.  To send
the commits associated with the tag you "push" them like:

#+begin_example
git push <remotename> <tagname>
#+end_example

** Advertising a release

After the git mechanics above are complete, the next step is to inform
the software manager that a new release has been made and requires
installation.  This notification should include at least:

 - the tag name you chose to release

 - the remote (cgit) repository URL

 - on which machines the software needs installing

 - installation and validation instructions

It is expected that only the first item will change from release to
release.




* Dependencies

As described above, your job finds input files that were output by any
jobs on which your job depends based on information that the harness
provides.  The harness gets this information from the LIMS database
but it must ultimately come from the test software developer.  You
need to communicate this to LIMS.

* Installation

Specifics are found in the document [[./installatin.org][LCATR Job Installation]].

